<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Sean Becker | Feed</title>
        <link>https://seanbecker.me</link>
        <description>Technology and Engineering Blog</description>
        <lastBuildDate>Sun, 03 Dec 2023 22:33:08 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Feed for Node.js</generator>
        <image>
            <title>Sean Becker | Feed</title>
            <url>https://seanbecker.me/logo.png</url>
            <link>https://seanbecker.me</link>
        </image>
        <copyright>Copyright 2023 Sean Becker</copyright>
        <item>
            <title><![CDATA[About Me]]></title>
            <link>https://seanbecker.me/posts/about-me</link>
            <guid>https://seanbecker.me/posts/about-me</guid>
            <pubDate>Sun, 03 Dec 2023 06:00:00 GMT</pubDate>
            <description><![CDATA[Just a few snippets of information to get to know me.]]></description>
            <content:encoded><![CDATA[
- I grew up in Vernon Hills, IL
- I went to Purdue University where I majored in Computer Science and minored in Business Management        
- I try to take at least one ski trip every year, usually on the west coast of the US
- I frequently listen to podcasts including Lex Fridman, Andrew Huberman, Joe Rogan, and Sam Harris
- I enjoy building all things related to technology. Please reach out if you have an idea and want advice on how to build it :)
        
Go back [home](/).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Past Projects]]></title>
            <link>https://seanbecker.me/posts/past-projects</link>
            <guid>https://seanbecker.me/posts/past-projects</guid>
            <pubDate>Sun, 03 Dec 2023 06:00:00 GMT</pubDate>
            <description><![CDATA[This is a list of some of the projects I've worked on in the past.]]></description>
            <content:encoded><![CDATA[
<ProjectList filter={({ active }) => !active} />

Go back [home](/).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Professional Experience]]></title>
            <link>https://seanbecker.me/posts/professional-experience</link>
            <guid>https://seanbecker.me/posts/professional-experience</guid>
            <pubDate>Sun, 03 Dec 2023 06:00:00 GMT</pubDate>
            <description><![CDATA[A brief summary of my professional experience.]]></description>
            <content:encoded><![CDATA[
## FuboTV - Senior Software Engineer, SmartTV (Present)
- [Redesigned SmartTV application](https://cordcuttersnews.com/fubo-is-rolling-out-a-new-improved-user-interface-with-re-designed-apps/) and launched to 300,000+ users.
- Built new sidebar found on LG, Samsung, Vizio, Hisense, and Xbox applications.
- Integrated new backend with existing player controls (i.e., the UI that allows users to control playback).
- Built tooling to improve developer efficiency.

## Fubo Gaming - Software Engineer
- Interviewed 70+ candidates for engineering roles. Scaled team from 5 to 15 engineers.
- Created template for making new Node.js packages that get published to Github npm registry.
- Rewrote authentication flow & integration between sportsbook and TV
    product; Coordinated effort between white-label provider, in-house
    designers, in-house frontend team, and in-house platform team.
- Integrated [Trustly](https://us.trustly.com) payment provider, simplifying deposit flow and substantially increasing first time deposit rate.
- Coordinated regulatory changes required to launch Fubo Sportsbook in Iowa, Arizona, and New Jersey.

## Prior Employment
For information on prior employment, you can view my resume [here](/public/docs/resume.pdf).

Go back [home](/).
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[OpenAI Series: Chat-GPT Style Completion Using SSE Streaming API]]></title>
            <link>https://seanbecker.me/posts/chatgpt-text-completion</link>
            <guid>https://seanbecker.me/posts/chatgpt-text-completion</guid>
            <pubDate>Mon, 04 Dec 2023 06:00:00 GMT</pubDate>
            <description><![CDATA[Let's use the OpenAI SSE streaming API to make a chatbot that can complete sentences just like ChatGPT.]]></description>
            <content:encoded><![CDATA[
# Chat-GPT Style Completion Using SSE Streaming

## Introduction

There are lots of things that make ChatGPT great under the hood. But let's face it, most people (myself included) will never truly understand the internals.
But that doesn't mean that the entire stack is a mystery.

## Why is this interface important?

If you've ever used the OpenAI API, you know that it's a bit slow without using the streaming API. It can take 10+ seconds to a receive
a response depending on the complexity of the prompt. Though the idea that users will leave your website if it takes more than 3 seconds to load is [probably a myth](https://www.reddit.com/r/webdev/comments/n66d0r/comment/gx5b2gl),
it is still very important to have good _perceived_ performance. Waiting for 10+ seconds leads to loss of context and a bad user experience.

Though the total response time is likely the same, the streaming API sends back partial responses as they are generated.
Users can see the response in real time and process the response as it is being generated. This makes a huge difference in the user experience.

## Let's get started

### Assumptions

- I'm using React for this example, but most of this code should be very easy to drop into other frameworks.
- I'm assuming that you already have a backend forwarding the OpenAI stream to your frontend. If not, I will be making a guide on how to do that soon.
{/* TODO */}
- Just looking for code? You can find that [here]().

### Prerequisites

```bash
npm install eventsource-parser
```

### Code


1. Create a component with form submission

  ```javascript
  import { useState, ChangeEvent } from "react";

  // Assuming that you have a function that fetches the completion from the OpenAI API
  import { fetchCompletion } from "./api";

  const Chatbot = () => {
    const [prompt, setPrompt] = useState("");
    const [completion, setCompletion] = useState("");

    const handleResponse = (response: Response) => {};

    const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
      setPrompt(e.target.value);
    };

    const handleSubmit = fetchCompletion(prompt).then(handleResponse)

    return (
      <div>
        <input type="text" value={text} onChange={handleChange} />
        <button type="button" onClick={handleSubmit}>Submit</button>
        <p>{completion}</p>
      </div>
    );
  }
  ```

1. Convert stream to async iterable ReadableStream

  ```javascript
    // Convert the stream to an async iterator.
    // Found here https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate
    async function* streamAsyncIterator(stream: ReadableStream) {
      const reader = stream.getReader();
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) return;
          yield value;
        }
      } finally {
        reader.releaseLock();
      }
    }

    ...

    const Chatbot = () => {
      ...

      const handleResponse = (response: Response) => {
        const stream = response.body;
        const asyncIteratorStream = streamAsyncIterator(stream);
        for await (const chunk of asyncIteratorStream) {
          console.log(chunk);
        }
      }
    }
  ```

1. Use eventsource-parser to parse the SSE stream

  ```javascript

  const Chatbot = () => {
    ...

    const parseEvent = (event: ParsedEvent | ReconnectInterval) => {
      console.log(event);
    };

    const handleResponse = (response: Response) => {
      ...
      const parser = createParser(parseEvent);
      for await (const chunk of asyncIteratorStream) {
        parser.feed(chunk);
      }
    }

    ...
  }
  
  ```

1. Update completion text as we get each event

  ```javascript
  const Chatbot = () => {
    ...

    const parseEvent = (event: ParsedEvent | ReconnectInterval) => {
      if (event.type !== 'event' || event.data === '[DONE]') {
        return
      }

      const delta = JSON.parse(event.data).choices[0]?.delta?.content || "";
      setCompletion((prev) => {
        if (prev) {
          return prev + delta;
        } else {
          return delta;
        }
      });
    };

    ...
  }
  ```]]></content:encoded>
        </item>
    </channel>
</rss>